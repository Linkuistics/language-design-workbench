grammar msbnf {
    
    // This is a meta-circular grammar, that is the definition its own format

    grammar = 'grammar' name '{' rule:( | rule | pratt_rule | identifier_rule )* '}' ;

    rule = name annotation:rule_annotation? version_annotation* '=' body:rule_body ';' ;
    rule_annotation = | no_skip:'@noskip' | atomic:'@atomic' ;

    pratt_rule = 'pratt' name version_annotation* '{' operators:pratt_operator+ primary:pratt_primary '}' ;
    pratt_operator = pratt_operator_type name version_annotation* '=' body:rule_body ';' ;
    pratt_primary = 'primary' name '=' body:rule_body ';' ;
    pratt_operator_type = | 'prefix' | 'postfix' | 'left' | 'right' ;

    identifier_rule = 'identifier' name rule_annotation? version_annotation* '=' ( | identifier_with_exclusions | rule_body ) ; 
    identifier_with_exclusions = '(' rule_body ')' 'excluding' '(' rule_body ')' ;

    version_annotation @noskip = version_annotation_type '(' version_number ')' ;
    version_annotation_type = | '@enabled' | '@disabled' ;
    version_number = segment:version_segment ( '.' segment:version_segment )* ;
    version_segment @atomic = [0-9]+ ;

    rule_body = | sequence_rule | alternative_rules ;
    
    sequence_rule = rule_element+ ;
    
    alternative_rules = alternative+ ;
    alternative = label? '|' version_annotation* sequence_rule ;
    
    rule_element = | counted_rule_element | negative_lookahead ;
    counted_rule_element = label? countable_rule_element count? version_annotation* ;
    countable_rule_element =
        | rule_reference
        | string
        | char_set
        | any
        | '(' rule_body ')'
        ;

    rule_reference @noskip = name ( '::' name )* ;

    count = | one_or_more:'+' | zero_or_more:'*' | optional:'?' ;

    identifier name @atomic = [a-zA-Z_] [a-zA-Z0-9_]* ;
    
    label @noskip = name ':' ;

    string @atomic =
        | "'" ( | [^'\\\n]* | ( "\\" ['\\] ) )* "'"
        | '"' ( | [^"\\\n]* | ( '\\' ["\\] ) )* '"'
        ;

    char_set @noskip = '[' negated:'^'? range:(start_char:char_set_char ( '-' end_char:char_set_char )?)+ ']' ;
    char_set_char @atomic = | [^\\\-\]] | '\\' [\^\\\-\]nt] ;
    
    any = '.' ;

    negative_lookahead @noskip = '!' ( | char_set | string ) ;

    trivia        @noskip = | line_comment | block_comment | whitespace ;
    line_comment  @atomic = '//' [^\n]* '\n'? ;
    block_comment @atomic = '/*' ( | [^*]+ | '*' !'/' )* '/' ;
    whitespace    @atomic = [\n\t ]+ ;

    /**************************************************************************

        Additional notes for  this grammar
        ==================================
        
        ## Grammar type

        MSBNF grammars may require backracking to parse correctly. They are not
        required to be LL(k) or LR(k) grammars.

        ## Trivia

        Trivia is a special kind of rule that is used to represent comments and
        whitespace.

        Trivia can appear between all elements in all rules except those marked
        as `@noskip` or `@atomic`.

        The `@noskip` annotation means that trivia is not allowed between the
        elements of the rule. The rule still has substructure, that must be
        preserved in the representation.

        The `@atomic` annotation means that rule represents a single spa of
        text, without any recorded structure. It implies the `@noskip`
        annotation.

        The trivia and comment rules given are for the msbnf language - each
        language may have different rules for trivia.

        ## IMPORTANT: Rule Structure Preservation

        All rules that are not explicitly marked as @atomic should preserve
        their substructure in any abstract model derived from this grammar. The
        @atomic annotation indicates that a rule represents a single span of
        text without recorded internal structure.

        For example:
        
        - A rule like "foo = bar baz;" must preserve "bar" and "baz" as separate
        elements.
        
        - A rule marked @atomic like "qux @atomic = [a-z]+;" can be represented
        as a simple string.

        Examine each rule carefully.
        
        Unless the rule is marked @atomic, represent its substructure in the
        model i.e. preserve the individual elements of which it is composed as
        separate data items.  You must never represent such a rule as a single
        string.
        
        The @atomic annotation does not imply anything about the nature of it's
        constituent elements.
        
        Pay special attention to rules with repetition, alternation, or nested
        structures.

        This principle applies to all rules in this grammar, including but not
        limited to complex rules like version_number, rule_body, and
        rule_element_sequence.

        ## Repetition operators

        MSBNF supports the following greedy repetition operators:
        - `*`: Zero or more occurrences
        - `+`: One or more occurrences
        - `?`: Zero or one occurrence

        ## References

        References are used to refer to other rules within the grammar.

        References using '::' can be used to refer to a rule in a different
        grammar. It is an implementation detail on how that name is resolved.
        This is used to allow grammars to be modular, and to allow language
        resuse and embedding.

        ## Alternatives

        A list of alternatives starts with a '|' character, because this gives a
        syntactic point to attach annotations to each branch of a list of
        alternatives.

        Alternatives use the ordered choice construct in parsing terms. This
        implies that parsers will need to backtrack when trying alternatives,
        because the grammar is ambiguous.

        ## Unparsing

        Unparsing is the process of converting a parse tree into a formatted
        string, also known as pretty-printing.

        MSBNF uses an sexpr (sub-)grammar to compute formatting tree that can be
        latter converted into a string.

        It references the `datum` rule from the `sexpr` grammar, and it is
        intended that the entire sexpr grammar is therefore accessible.

        The interpretation of the sexpr grammar is left to the implementation
        i.e. it is not part of this grammar.

        ## Pratt parsing

        A Pratt parser, also known as a top-down operator precedence parser, is
        a parser that uses a Pratt-style algorith to decide how to parse an
        input string.

        MSBNF uses Pratt parsing to handle expression grammars with operators,
        and allows the designer to mark a given rule as being an operator
        precendence rule that uses Pratt parsing.

        The operator definitions do not include references to their operands,
        which are implied to be the enclosing Pratt rule.

        The primary rule is the 'base case' rule, which is the rule that is used
        to parse the input string when there are no more operators to apply.

        The operators are listed in the order of precedence, with the highest
        precedence operator listed first.

        ## Identifier parsing

        There is often a conflict between the need to parse identifiers and the
        need to parse keywords.

        MSBNF allows the user to specify identifier rules that are general, but
        exclude keywords.  Any parse that matches the first rule is checked
        against the second rule, and if it matches, it is considered to not
        match the identifier rule.

        ## Labels

        Labels are used to attach a name to an element in a rule, or an
        alternative within a rule. Labels allow substructure to be named, which
        is used both when generating a parse tree, and when unparsing a parse
        tree.

        ## Negative lookahead

        Negative lookahead is kept deliberately simple, to improve the
        performance of the parser.

        ## Versioning annotations

        MSBNF is designed to allow multiple versions of the grammar to be
        specified in the same file.

        Versioning annotations are used to enable and disable certain rules or
        elements within rules depending on the version of the language being
        used.

        When a parser is generated from the grammar, the parser will take a
        version number as an argument, and will only enable the rules and
        elements that are enabled for that version.

    **************************************************************************/

}
grammar model {
    
    Model =
        'model' name:Id 
        ( 'modifies' parent_name:Id )? 
        '{' ( ( | Definition | Deletion | MemberModification ) ';' )* '}'
        ;

    Definition = name:Id '=' Type  ;
    Deletion = 'delete' name:Id  ;
    MemberModification = 'modify' name:Id ( | MemberDeletion | MemberAddition )+ ;
    MemberDeletion = '-=' ( | name:Id | NamedTypeReference ) ; 
    MemberAddition = '+=' ( | Type | ProductMember ) ;


    /************************************
     * Types
     ************************************/

    Type = | VoidType | PrimitiveType | EnumType | TypeWithStructure | NamedTypeReference ;

    VoidType = '()' ;
    PrimitiveType = type: (| 'boolean' | 'char' | 'string' | 'i8' | 'i16' | 'i32' | 'i64' | 'u8' | 'u16' | 'u32' | 'u64' | 'f32' | 'f64') ;
    EnumType = '{' member:String ( '|' member:String )* ) '}' ;
    String @noskip = '"' Id '"' ;

    TypeWithStructure = | SumType | ProductType | GenericType ;
    
    SumType = '{' member:Type ( '|' member:Type )+ '}' ;

    ProductType = '{' ( member:ProductMember ( ',' member:ProductMember )* )? '}' ;
    ProductMember = name:Id ':' Type ;

    GenericType = | TupleType | MapType | SetType | OptionType | ResultType ;
    TupleType = 'tuple<' member:Type ( ',' member:Type )* '>' ;
    MapType = 'map<' key_type:Type ',' value_type:Type '>' ;
    SetType = 'set<' key_type:Type '>' ;
    SequenceType = 'seq<' Type '>' ;
    OptionType = 'option<' Type '>' ;
    ResultType = 'result<' ok_type:Type ',' err_type:Type '>' ;

    NamedTypeReference @noskip = name:Id ( '::' name:Id )* ;


    /************************************
     * Identifiers
     ************************************/

    identifier Id         @atomic = InitialIdentifierChar ( IdentifierChar )* ;
    InitialIdentifierChar @atomic = [a-zA-Z_] ;
    IdentifierChar        @atomic = [a-zA-Z_0-9] ;


    /************************************
     * Trivia
     ************************************/

    Trivia        @noskip = | LineComment | BlockComment | Whitespace ;
    Whitespace    @atomic = [\n\t ]+ ;
    LineComment  @atomic = '//' [^\n]* '\n'? ;
    BlockComment @atomic = '/*' ( | [^*]+ | '*' !'/' )* '/' ;

}